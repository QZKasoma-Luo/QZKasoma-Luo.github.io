<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Human-Computer-Interaction Summary 1</title>
      <link href="/2023/09/28/Human-Computer-Interaction-Summary-1/"/>
      <url>/2023/09/28/Human-Computer-Interaction-Summary-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/IMG_2032.jpeg"></p><h2 id="In-the-Human-Centered-design-process"><a href="#In-the-Human-Centered-design-process" class="headerlink" title="In the Human-Centered design process"></a>In the Human-Centered design process</h2><p>After understanding and specify context of use, the specify user requirements:</p><ul><li>Functional requirements (what the interface will do)</li><li>Non-functional requirements (constraints)</li></ul><h2 id="What-is-a-requirement"><a href="#What-is-a-requirement" class="headerlink" title="What is a requirement?"></a>What is a requirement?</h2><ul><li>A statement about an intended product that specifies what it is expected to do or how it will perform it.</li><li>Examples: For a map application, the requirement could be that the time to load the map must be less than half a second, or for a smartwatch, the requirement could be that the interface should be made attractive for teenagers.</li></ul><h2 id="By-discovering-and-communicating-requirements"><a href="#By-discovering-and-communicating-requirements" class="headerlink" title="By discovering and communicating requirements:"></a>By discovering and communicating requirements:</h2><ul><li>Helps us tell the developers what to build.</li><li>Allows users to verify and contribute towards the development.</li><li>Overall advancing our goal to build usable system and one that meets the needs of people.</li></ul><h2 id="Requirements-Gathering-and-communication"><a href="#Requirements-Gathering-and-communication" class="headerlink" title="Requirements Gathering and communication:"></a>Requirements Gathering and communication:</h2><ul><li>Happens iteratively and could be gathered from different stages of HCD process.</li><li>Over a period of time, requirements could change completely. For example, our requirements from our smartphone today are very different from early phones such as landline phone and early cell phones.</li></ul><h2 id="Types-of-requirements"><a href="#Types-of-requirements" class="headerlink" title="Types of requirements:"></a>Types of requirements:</h2><ul><li>Functional (what people need)<ol><li>Describe what the product will do.</li><li>E.g., new video game</li><li>Client wants a beginner level squash video game that supports signle or two-players.</li><li>Has to capture player data continuously.</li></ol></li><li>Non-functional (what people expect)<ol><li>Describe the constraints (physical, logical, semantic, culture, technical) and aesthetics style.</li><li>E.g., new video game</li><li>End-users would expect the game works on Xbox if found on Xbox store.</li><li>Client expects that the gameplay and aesthetics of the game should be modern.</li></ol></li></ul><h2 id="How-do-we-capture-requirements"><a href="#How-do-we-capture-requirements" class="headerlink" title="How do we capture requirements?"></a>How do we capture requirements?</h2><ul><li>Secondary research: Read patents and research articles that explain in detail how systems have been developed and also do a good job outlining the rationale.</li><li>Study existing products and systems.</li><li>Interact with potential end-users: Engage in UX research using methods such as interviews, surveys, diary studies, ethnography and other methods.</li></ul><h2 id="Task-Centered-system-design-TCSD"><a href="#Task-Centered-system-design-TCSD" class="headerlink" title="Task Centered system design (TCSD)"></a>Task Centered system design (TCSD)</h2><ul><li>A method to identify meaningful tasks that people want to or have to accomplish using a system, and</li><li>Using those tasks to propose new ideas or improvements for UI design.</li></ul><h2 id="Developing-Tasks"><a href="#Developing-Tasks" class="headerlink" title="Developing Tasks:"></a>Developing Tasks:</h2><ol><li>Say what the user wants to do but does not say how they would do it.<br>a. No assumptions made about the interface.<br>b. No mention of the interface in the task helps designer brainstorm all potential options for UI.</li><li>Are very specific.<br>a. Say exactly what the user wants to do.<br>b. Specify actual information the user would somehow want to input.<br>c. Helps designers think through the types of inputs the system will need to process and perhaps store.</li><li>Describe a complete job.<br>a. Tell designers about how information flows through the system.<br>i. Where does information come from?<br>ii. Where does it go?<br>iii. What has to happen next?<br>b. Ask designers to consider how many system features are required and how they will work with each other.</li><li>Say who the users are.<br>a. Helps the designer understand who will be using the system, how and their context of use.</li><li>As a set, cover a range of possibilities.<br>a. The potential users of the systems-primary occasional and least likely to use the system.<br>b. Types of tasks – routine important but infrequent, unexpected, or rarely performed.</li></ol><h2 id="Which-user-groups-will-be-addressed-by-the-interface"><a href="#Which-user-groups-will-be-addressed-by-the-interface" class="headerlink" title="Which user groups will be addressed by the interface?"></a>Which user groups will be addressed by the interface?</h2><ul><li>Designs can rarely handle everyone; we typically need feature-level customization to reach a broad audience.</li></ul><h2 id="Which-task-will-be-addressed-by-the-interface"><a href="#Which-task-will-be-addressed-by-the-interface" class="headerlink" title="Which task will be addressed by the interface?"></a>Which task will be addressed by the interface?</h2><ul><li>Absolutely must include.</li><li>Should include.</li><li>Could include.</li><li>Exclude for the current round of development.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transitive Closure and Floyd-Warshall&#39;s Algorithm</title>
      <link href="/2023/09/25/Transitive-Closure-and-Floyd-Warshall-s-Algorithm/"/>
      <url>/2023/09/25/Transitive-Closure-and-Floyd-Warshall-s-Algorithm/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Morning.jpeg"></p><h2 id="Transitive-Closure"><a href="#Transitive-Closure" class="headerlink" title="Transitive Closure"></a>Transitive Closure</h2><p>Transitive closure refers to a concept used in graph theory and relations, specifically in directed graphs. It represents the complete set of nodes or elements that can be reached from a given node through a chain of directed edges or relations. In simpler terms, it tells us all the possible destinations we can reach from a starting point by following a series of directed connections, considering the indirect connections as well.</p><h2 id="Floyd-Warshall’s-Algorithm"><a href="#Floyd-Warshall’s-Algorithm" class="headerlink" title="Floyd-Warshall’s Algorithm"></a>Floyd-Warshall’s Algorithm</h2><p>The Floyd-Warshall algorithm is a method for finding the shortest paths between all pairs of nodes in a graph, which may include directed edges with associated weights. It works by iteratively updating the shortest path information until it calculates the shortest paths between all pairs of nodes. The algorithm considers the possibility of indirect paths to find the most efficient way to reach any node from any other node within the graph. It’s like finding the best routes to travel between any two places on a road network, taking into account all possible connections, to minimize travel time or distance.</p><pre><code>function FloydWarshall(graph):    n ← number of vertices in the graph    dist ← a 2D array of size n x n, initialized with infinity    // Initialize distances for direct edges    for each vertex v in graph:        dist[v][v] ← 0        for each neighbor u of v:            dist[v][u] ← weight of edge (v, u)    // Calculate shortest paths between all pairs    for k from 1 to n:        for i from 1 to n:            for j from 1 to n:                // If there's a shorter path from i to j through vertex k                if dist[i][k] + dist[k][j] &lt; dist[i][j]:                    dist[i][j] ← dist[i][k] + dist[k][j]    return dist</code></pre><h2 id="The-relationship-between-the-Floyd-Warshall-algorithm-and-Transitive-Closure-can-be-described-as-follows"><a href="#The-relationship-between-the-Floyd-Warshall-algorithm-and-Transitive-Closure-can-be-described-as-follows" class="headerlink" title="The relationship between the Floyd-Warshall algorithm and Transitive Closure can be described as follows:"></a>The relationship between the Floyd-Warshall algorithm and Transitive Closure can be described as follows:</h2><ol><li><p><strong>Floyd-Warshall Algorithm</strong>:</p><ul><li>The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a directed graph. It employs dynamic programming to compute the shortest path length from one node to another, considering all possible intermediate nodes.</li><li>This algorithm is primarily concerned with path computation, specifically the shortest path problem, and is commonly used in weighted graphs where edges have weights or distances.</li><li>The Floyd-Warshall algorithm not only computes the shortest path lengths but also provides information about the actual shortest paths, making it useful for determining the optimal route from one node to another.</li></ul></li><li><p><strong>Transitive Closure</strong>:</p><ul><li>Transitive closure is a concept in relation theory used to describe transitive relationships within a directed graph or relation. It represents the complete set of nodes or elements that can be reached from a given starting point through a series of directed edges or relations.</li><li>Transitive closure primarily focuses on transitive relationships between nodes and is typically used to determine whether there are transitive dependencies or relationships between nodes.</li></ul></li></ol><p>Relationship:</p><ul><li>In some cases, the Floyd-Warshall algorithm can be used to compute the transitive closure of a graph. When you have a directed graph with weighted edges, where the weights represent the strength or distance of relationships, the resulting matrix of shortest path lengths obtained from the Floyd-Warshall algorithm can effectively represent the transitive closure of the graph.</li></ul><p>In summary, both the Floyd-Warshall algorithm and Transitive Closure involve relationships between nodes in a directed graph, but they have distinct focuses and applications. The Floyd-Warshall algorithm is used for finding shortest paths, while Transitive Closure is used for describing transitive relationships. However, in certain scenarios, the Floyd-Warshall algorithm can be applied to compute the transitive closure, especially when the graph’s edges represent transitive relationships.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DAGs and Topological Sorting</title>
      <link href="/2023/09/15/DAGs-and-Topological-Sorting/"/>
      <url>/2023/09/15/DAGs-and-Topological-Sorting/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Victoria.jpeg"></p><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><p>A Directed Acyclic Graph (DAG) is a type of graph structure composed of a set of nodes and a set of directed edges, where each edge has a direction, pointing from one node to another, and the graph does not contain any cycles (meaning you cannot start at one node and follow directed edges to return to the same node). Therefore, a DAG is a directed graph without cycles.</p><p>DAGs find extensive applications in various fields such as task scheduling, compiler optimization, dependency analysis, and more. In these applications, DAGs are typically used to represent dependencies between tasks or data flows within computational processes.</p><h2 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a>Topological Sorting</h2><p>Topological sorting is a fundamental algorithm used in graph theory and project management to linearly order the nodes (or tasks) of a directed acyclic graph (DAG). The goal of topological sorting is to arrange the nodes in such a way that for every directed edge (u, v), node u appears before node v in the linear order. In other words, it establishes a consistent sequence for completing tasks or processing elements while respecting their dependencies.</p><p>Key points about topological sorting:</p><ol><li><p><strong>Directed Acyclic Graph (DAG)</strong>: Topological sorting can only be applied to directed graphs that have no cycles. This is because cycles introduce ambiguity in the order of tasks, making a topological order impossible.</p></li><li><p><strong>Dependency Resolution</strong>: Topological sorting is particularly useful when you have a set of tasks or activities with dependencies. It ensures that tasks are executed in the correct order, so a task that depends on another is never started before its prerequisites are completed.</p></li><li><p><strong>Applications</strong>:</p><ul><li><strong>Project Management</strong>: Topological sorting helps schedule tasks in projects to ensure that the project is completed on time.</li><li><strong>Compiler Optimization</strong>: In compiler design, it helps determine the optimal order for generating code or optimizing program segments.</li><li><strong>Dependency Analysis</strong>: Used in software engineering to analyze dependencies between modules, functions, or classes.</li><li><strong>Course Scheduling</strong>: In academic institutions, it assists in scheduling courses based on prerequisites.</li></ul></li><li><p><strong>Algorithm</strong>: Several algorithms can perform topological sorting. Depth-First Search (DFS) and Breadth-First Search (BFS) are commonly used approaches. The choice of algorithm depends on the specific requirements of the problem.</p></li><li><p><strong>Critical Path</strong>: Topological sorting can also identify the critical path in a project, which is the longest path through the graph. Tasks on the critical path are the ones that, if delayed, will delay the entire project.</p></li><li><p><strong>Multiple Valid Orders</strong>: It’s important to note that in a given DAG, there can be multiple valid topological orders. This flexibility allows for optimization, parallel processing, and resource allocation.</p></li></ol><p>Overall, topological sorting is a powerful tool for managing dependencies and ensuring tasks are executed in the correct order in a wide range of applications where directed acyclic graphs are prevalent.</p><p>There are two commonly used algorithms for performing topological sorting on a Directed Acyclic Graph (DAG): Depth-First Search (DFS) and Breadth-First Search (BFS). Both algorithms can be used to find a valid topological order for the nodes in the graph. Here’s an explanation of each algorithm:</p><ol><li><p><strong>Depth-First Search (DFS) Algorithm</strong>:</p><ul><li>Start from an arbitrary node in the DAG.</li><li>Perform a depth-first traversal of the graph, marking nodes as visited.</li><li>When you reach a node with no unvisited neighbors (i.e., a leaf node), add it to the beginning of the topological order.</li><li>Continue this process until all nodes have been visited.</li></ul><p>Pseudocode for the DFS-based topological sorting algorithm:</p><pre><code>function topologicalSort(graph):initialize an empty list for the topological orderinitialize a set to keep track of visited nodes    for each node in graph:        if node is not visited:            visit(node, topological order, visited)    return reverse of the topological order listfunction visit(node, topological order, visited):    mark node as visited    for each neighbor of node:    if neighbor is not visited:    visit(neighbor, topological order, visited)    append node to the topological order list</code></pre></li><li><p><strong>Breadth-First Search (BFS) Algorithm</strong>:</p><ul><li>Initialize an empty queue and a list to store the topological order.</li><li>Start by enqueueing all nodes with no incoming edges (in-degree of 0).</li><li>While there are nodes in the queue, do the following:<ul><li>Dequeue a node, add it to the topological order list.</li><li>For each of its neighbors, reduce their in-degrees by 1.</li><li>If a neighbor’s in-degree becomes 0, enqueue that neighbor.</li></ul></li><li>Repeat the above process until the queue is empty.</li></ul><p>Pseudocode for the BFS-based topological sorting algorithm:</p><pre><code>function topologicalSort(graph):initialize an empty list for the topological orderinitialize a queue for nodes with in-degrees of 0    for each node in graph:        if in-degree of node is 0:            enqueue(node)    while queue is not empty:        node = dequeue(queue)        append node to topological order list        for each neighbor of node:            reduce in-degree of neighbor by 1            if in-degree of neighbor is 0:                enqueue(neighbor)    return topological order list</code></pre></li></ol><p>Both DFS and BFS-based algorithms will produce a valid topological order for a DAG. The choice between them depends on factors like performance and specific requirements of the problem.</p><h2 id="Computing-a-topological-sort-of-G-is-O-n-m-for-V-n-and-E-m"><a href="#Computing-a-topological-sort-of-G-is-O-n-m-for-V-n-and-E-m" class="headerlink" title="Computing a topological sort of G is O(n+m) for V = n and E = m"></a>Computing a topological sort of G is O(n+m) for V = n and E = m</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
